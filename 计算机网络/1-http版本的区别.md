### http 不同版本之间的区别

#### http/0.9

- http/0.9 是最早发布的一个版本，只接受 GET 请求方法。
- 不需要指定 http 的版本，也不支持请求头。
- 仅支持传输纯文本格式的数据

#### http/1.0

http/1.0 是 http 协议的第二个版本，相比于 0.9 版本。

- http/1.0 支持了更多的请求方法，比如 POST、HEAD 等。
- http/1.0 支持了请求头，一个请求报文由 header+body 构成。
- 不再局限于纯文本格式的数据，可以通过 `Content-Type` 字段告诉服务器客户端支持的内容类型。
- 支持缓存 Cache,即客户端在规定时间内访问同一个网站，直接从 cache 中获取。（强缓存：`expires`,协商缓存：`last-modified，if-modified-Since`）
- 支持状态码
- 1.0 版本的工作方式是每次请求资源的时候，都需要建立 `TCP` 连接，然后发送请求，服务器响应完成之后就会关闭这次的连接，下一个请求需要再次建立连接。这就使得 1.0 版本的性能比较差，因为建立 TCP 连接的成本较高，为了解决这个问题，有些浏览器在请求时，支持 `Connection` 字段，即在请求头部加上 `Connection：keep-alive`。告诉服务器不要关闭 TCP 连接，这时候，客户端与服务器建立连接之后，客户端就可以多次请求资源，直到客户端或者服务器主动关闭连接，或者长时间没有数据交互，服务器会断开连接。但是 1.0 版本中，connection 不是一个标准的字段。

#### http/1.1

- 在 1.1 版本中，默认采用持久连接（`Connection：keep-alive`）
- 支持以`管道方式`发送多个请求
  - 所谓管道方式就是，在一个 TCP 连接中，允许客户端同时发送多个请求，假设客户端需要请求两个资源。
  - 以前的做法是，在同一个 TCP 连接中，先发送 A 请求，等到服务器作出回应，收到以后在发送 B 请求。
  - 管道机制则是客户端可以直接发送 A 请求，发送完不需要等待 A 的响应，直接发送 B 请求，但是服务器处理请求的时候还是要按照顺序来处理。
  - 在以前如果 A 请求发出去以后，A 的处理时间比较长，那么 B 请求就不能发送，就造成了`请求的队头阻塞`。但是在 http/1.1 中就没有这个问题了
  - 所以 1.1 版本解决了请求的队头阻塞，但是没有解决响应的队头阻塞，服务器还是要按照顺序处理响应
- 引入了更多的缓存控制策略，强缓存：`Cache-Control`,协商缓存：`Etag 和 If-None-Match`
- 新增了请求方式 PUT、PATCH、OPTIONS、DELETE 等

#### http/2.0

- 二进制协议：1.1 版本中的头部信息是文本，数据体可以是文本也可以是二进制数据。http/2.0 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为`帧`:头信息帧和数据帧。
- 多路复用：即在一个连接中，客户端和服务器都可以发送多个请求或者响应，而且不用按照顺序一一对应，这样做的前提是 http/2.0 进行了二进制分帧。即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。
- 头部信息压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP 2.0 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
- 服务器推送：允许服务器主动的向客户端发送资源。即向支持 http/2.0 的服务器请求数据的时候，服务器会顺把一些客户端需要的资源一起发送给客户端，这个资源会被存储在客户端的某个位置，下次请求的时候就可以直接从本地加载，不用发送网络请求。非常适合加载一些静态资源。
